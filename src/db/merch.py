# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.30.0
# source: merch.sql
import pydantic
from typing import AsyncIterator, Iterator, Optional
import uuid

import sqlalchemy
import sqlalchemy.ext.asyncio

from db import models


CREATE_MERCH = """-- name: create_merch \\:one
insert into merch (name, info, image_url, points_needed)
values (:p1, :p2, :p3, :p4)
returning id, name, info, image_url, points_needed
"""


DELETE_MERCH = """-- name: delete_merch \\:exec
delete from merch
where id = :p1
returning id
"""


GET_ALL_MERCH = """-- name: get_all_merch \\:many
select id, name, info, image_url, points_needed from merch
ORDER BY name
"""


GET_MERCH_BY_ID = """-- name: get_merch_by_id \\:one
select id, name, info, image_url, points_needed from merch
where id = :p1
"""


UPDATE_MERCH = """-- name: update_merch \\:one
update merch
set
    name   = coalesce(:p2, name),
    info  = coalesce(:p3, info),
    image_url  = coalesce(:p4, image_url),
    points_needed  = coalesce(:p5, points_needed)
where
    id = :p1
returning id, name, info, image_url, points_needed
"""


class UpdateMerchParams(pydantic.BaseModel):
    id: uuid.UUID
    name: Optional[str]
    info: Optional[str]
    image_url: Optional[str]
    points_needed: Optional[int]


class Querier:
    def __init__(self, conn: sqlalchemy.engine.Connection):
        self._conn = conn

    def create_merch(self, *, name: str, info: str, image_url: str, points_needed: int) -> Optional[models.Merch]:
        row = self._conn.execute(sqlalchemy.text(CREATE_MERCH), {
            "p1": name,
            "p2": info,
            "p3": image_url,
            "p4": points_needed,
        }).first()
        if row is None:
            return None
        return models.Merch(
            id=row[0],
            name=row[1],
            info=row[2],
            image_url=row[3],
            points_needed=row[4],
        )

    def delete_merch(self, *, id: uuid.UUID) -> None:
        self._conn.execute(sqlalchemy.text(DELETE_MERCH), {"p1": id})

    def get_all_merch(self) -> Iterator[models.Merch]:
        result = self._conn.execute(sqlalchemy.text(GET_ALL_MERCH))
        for row in result:
            yield models.Merch(
                id=row[0],
                name=row[1],
                info=row[2],
                image_url=row[3],
                points_needed=row[4],
            )

    def get_merch_by_id(self, *, id: uuid.UUID) -> Optional[models.Merch]:
        row = self._conn.execute(sqlalchemy.text(GET_MERCH_BY_ID), {"p1": id}).first()
        if row is None:
            return None
        return models.Merch(
            id=row[0],
            name=row[1],
            info=row[2],
            image_url=row[3],
            points_needed=row[4],
        )

    def update_merch(self, arg: UpdateMerchParams) -> Optional[models.Merch]:
        row = self._conn.execute(sqlalchemy.text(UPDATE_MERCH), {
            "p1": arg.id,
            "p2": arg.name,
            "p3": arg.info,
            "p4": arg.image_url,
            "p5": arg.points_needed,
        }).first()
        if row is None:
            return None
        return models.Merch(
            id=row[0],
            name=row[1],
            info=row[2],
            image_url=row[3],
            points_needed=row[4],
        )


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def create_merch(self, *, name: str, info: str, image_url: str, points_needed: int) -> Optional[models.Merch]:
        row = (await self._conn.execute(sqlalchemy.text(CREATE_MERCH), {
            "p1": name,
            "p2": info,
            "p3": image_url,
            "p4": points_needed,
        })).first()
        if row is None:
            return None
        return models.Merch(
            id=row[0],
            name=row[1],
            info=row[2],
            image_url=row[3],
            points_needed=row[4],
        )

    async def delete_merch(self, *, id: uuid.UUID) -> None:
        await self._conn.execute(sqlalchemy.text(DELETE_MERCH), {"p1": id})

    async def get_all_merch(self) -> AsyncIterator[models.Merch]:
        result = await self._conn.stream(sqlalchemy.text(GET_ALL_MERCH))
        async for row in result:
            yield models.Merch(
                id=row[0],
                name=row[1],
                info=row[2],
                image_url=row[3],
                points_needed=row[4],
            )

    async def get_merch_by_id(self, *, id: uuid.UUID) -> Optional[models.Merch]:
        row = (await self._conn.execute(sqlalchemy.text(GET_MERCH_BY_ID), {"p1": id})).first()
        if row is None:
            return None
        return models.Merch(
            id=row[0],
            name=row[1],
            info=row[2],
            image_url=row[3],
            points_needed=row[4],
        )

    async def update_merch(self, arg: UpdateMerchParams) -> Optional[models.Merch]:
        row = (await self._conn.execute(sqlalchemy.text(UPDATE_MERCH), {
            "p1": arg.id,
            "p2": arg.name,
            "p3": arg.info,
            "p4": arg.image_url,
            "p5": arg.points_needed,
        })).first()
        if row is None:
            return None
        return models.Merch(
            id=row[0],
            name=row[1],
            info=row[2],
            image_url=row[3],
            points_needed=row[4],
        )
