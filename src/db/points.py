# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.28.0
# source: points.sql
from typing import Optional
import uuid

import sqlalchemy
import sqlalchemy.ext.asyncio

from db import models


GET_POINTS_BY_USER_ID = """-- name: get_points_by_user_id \\:one
SELECT user_id, total_points FROM points
WHERE user_id = :p1
"""


UPSERT_POINTS = """-- name: upsert_points \\:one
INSERT INTO points (user_id, total_points)
VALUES (:p1, :p2)
ON CONFLICT (user_id) DO UPDATE SET
    total_points = points.total_points + EXCLUDED.total_points
RETURNING user_id, total_points
"""


class Querier:
    def __init__(self, conn: sqlalchemy.engine.Connection):
        self._conn = conn

    def get_points_by_user_id(self, *, user_id: uuid.UUID) -> Optional[models.Point]:
        row = self._conn.execute(sqlalchemy.text(GET_POINTS_BY_USER_ID), {"p1": user_id}).first()
        if row is None:
            return None
        return models.Point(
            user_id=row[0],
            total_points=row[1],
        )

    def upsert_points(self, *, user_id: uuid.UUID, total_points: int) -> Optional[models.Point]:
        row = self._conn.execute(sqlalchemy.text(UPSERT_POINTS), {"p1": user_id, "p2": total_points}).first()
        if row is None:
            return None
        return models.Point(
            user_id=row[0],
            total_points=row[1],
        )


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def get_points_by_user_id(self, *, user_id: uuid.UUID) -> Optional[models.Point]:
        row = (await self._conn.execute(sqlalchemy.text(GET_POINTS_BY_USER_ID), {"p1": user_id})).first()
        if row is None:
            return None
        return models.Point(
            user_id=row[0],
            total_points=row[1],
        )

    async def upsert_points(self, *, user_id: uuid.UUID, total_points: int) -> Optional[models.Point]:
        row = (await self._conn.execute(sqlalchemy.text(UPSERT_POINTS), {"p1": user_id, "p2": total_points})).first()
        if row is None:
            return None
        return models.Point(
            user_id=row[0],
            total_points=row[1],
        )
