# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.28.0
# source: analytics.sql
import datetime
import decimal
import pydantic
from typing import AsyncIterator, Iterator, Optional
import uuid

import sqlalchemy
import sqlalchemy.ext.asyncio

from db import models


CREATE_ANALYTICS = """-- name: create_analytics \\:one
INSERT INTO analytics (user_id, stand_id) VALUES (:p1, :p2) RETURNING id, user_id, stand_id, time
"""


GET_ANALYTICS_GROUPED = """-- name: get_analytics_grouped \\:many
SELECT DATE(time) as date, EXTRACT(hour from time) as hour, COUNT(*) as count
FROM analytics
GROUP BY DATE(time), EXTRACT(hour from time)
ORDER BY DATE(time), EXTRACT(hour from time)
"""


class GetAnalyticsGroupedRow(pydantic.BaseModel):
    date: datetime.date
    hour: decimal.Decimal
    count: int


class Querier:
    def __init__(self, conn: sqlalchemy.engine.Connection):
        self._conn = conn

    def create_analytics(self, *, user_id: Optional[uuid.UUID], stand_id: Optional[uuid.UUID]) -> Optional[models.Analytic]:
        row = self._conn.execute(sqlalchemy.text(CREATE_ANALYTICS), {"p1": user_id, "p2": stand_id}).first()
        if row is None:
            return None
        return models.Analytic(
            id=row[0],
            user_id=row[1],
            stand_id=row[2],
            time=row[3],
        )

    def get_analytics_grouped(self) -> Iterator[GetAnalyticsGroupedRow]:
        result = self._conn.execute(sqlalchemy.text(GET_ANALYTICS_GROUPED))
        for row in result:
            yield GetAnalyticsGroupedRow(
                date=row[0],
                hour=row[1],
                count=row[2],
            )


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def create_analytics(self, *, user_id: Optional[uuid.UUID], stand_id: Optional[uuid.UUID]) -> Optional[models.Analytic]:
        row = (await self._conn.execute(sqlalchemy.text(CREATE_ANALYTICS), {"p1": user_id, "p2": stand_id})).first()
        if row is None:
            return None
        return models.Analytic(
            id=row[0],
            user_id=row[1],
            stand_id=row[2],
            time=row[3],
        )

    async def get_analytics_grouped(self) -> AsyncIterator[GetAnalyticsGroupedRow]:
        result = await self._conn.stream(sqlalchemy.text(GET_ANALYTICS_GROUPED))
        async for row in result:
            yield GetAnalyticsGroupedRow(
                date=row[0],
                hour=row[1],
                count=row[2],
            )
